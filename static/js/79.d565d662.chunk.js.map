{"version":3,"sources":["../../src/TransportU2F.js"],"names":["wrapU2FTransportError","originalError","message","id","err","webSafe64","base64","attemptExchange","keyHandle","apdu","result","Buffer","i","key","wrapApdu","challenge","signRequest","version","appId","location","origin","log","timeoutMillis","response","signatureData","data","substring","transportInstances","constructor","scrambleKey","unwrap","a","this","e","u2fError","t","setScrambleKey","setUnwrap","close","Promise","TransportU2F","isSupported","list","supported","listen","observer","unsubscribed","type","descriptor","unsubscribe"],"mappings":"yRAOA,SAASA,EAAsBC,EAAeC,EAASC,GACrD,IAAMC,EAAM,IAAI,EAAJ,iBAD6C,GAIzD,OADAA,kBACA,EAYF,IAAMC,EAAaC,YAAD,OAChBA,sDADF,KAQA,SAASC,EAAgB,EAAzB,OAME,IAAMC,EAvBR,SAAkBC,EAAlB,GAEE,IADA,IAAMC,EAASC,QAAaF,EAA5B,QACSG,EAAT,EAAgBA,EAAIH,EAApB,OAAiCG,IAC/BF,KAAYD,KAAUI,EAAID,EAAIC,EAA9BH,QAEF,SAkBkBI,CAASL,EAA3B,GACMM,EAAYJ,0EAAlB,OAIMK,EAAc,CAClBC,QADkB,SAElBT,UAAWH,EAAUG,WAFH,WAGlBO,UAAWV,EAAUU,WAHH,WAIlBG,MAAOC,SAASC,QAGlB,OADAC,YAAI,OAAQ,MAAQZ,WAApBY,QACO,eAAKL,EAAaM,EAAlB,WAA8CC,YACnD,IAvBcjB,EAuBNkB,EAAR,EAAQA,cACR,qBAAWA,EAA4B,CACrC,IACA,EADMC,EAAOd,QAzBDL,EAyBCK,GAxBjBL,oCACA,KAAKoB,UAAU,EAAI,EAAIpB,EAAL,OAFpB,GAyBM,UAQA,OAHEI,EAHF,EAGWe,QAATf,GAFAA,EAIFW,YAAI,OAAQ,MAAQX,WAApBW,QACA,EAEA,WAKN,IAAIM,EAAJ,G,IAkBe,E,kDA+CbC,aAAc,kCACZ,gBAZFC,iBAWc,IATdC,QAAkB,EAWhBH,uBAFY,E,mFAUd,uBAAAI,EAAA,+EAEiBxB,EAAgB,EAE3ByB,KAF0B,gBAG1BA,KAH0B,YAI1BA,KAJF,QAFJ,6EASI,kBAA0BC,KAAP,UATvB,uBAnEA,IA8EM,KA9ECC,gBALPP,WAA4BQ,YAAD,OAAOA,OAAlCR,iBACAA,MAsFY3B,EAAsB,EAAD,GAEzB,0CAA4CiC,cAFnB,KAGzB,OAASA,cAHX,MAfN,4E,mFA4BAG,SAAc,GACZJ,KAAA,YAAmBrB,SAAnB,W,uBAKF0B,SAAS,GACPL,KAAA,W,mBAGFM,WAEE,OAAOC,QAAP,a,0DAtDF,2JACS,IAAP,GADF,2C,4DA3Ca,KAAMC,EACZC,YAAcA,cADFD,EAKZE,KAAO,kBAEZD,8BAAoBE,YAAD,OAAgBA,EAAY,CAAH,MAA5CF,OAPiBD,EAWZI,OAAUC,YACf,IAAIC,GAAJ,EAiBA,OAhBAL,8BAAoBE,YAClB,IACA,GACEE,OAAc,CAAEE,KAAF,MAAeC,WAAY,OACzCH,cAEAA,QACE,IAAI,EAAJ,eACE,mJAFJA,wBAUG,CACLI,YAAa,WACXH,S","file":"static/js/79.d565d662.chunk.js","sourcesContent":["//@flow\n\nimport { sign, isSupported } from \"u2f-api\";\nimport Transport from \"@ledgerhq/hw-transport\";\nimport { log } from \"@ledgerhq/logs\";\nimport { TransportError } from \"@ledgerhq/errors\";\n\nfunction wrapU2FTransportError(originalError, message, id) {\n  const err = new TransportError(message, id);\n  // $FlowFixMe\n  err.originalError = originalError;\n  return err;\n}\n\nfunction wrapApdu(apdu: Buffer, key: Buffer) {\n  const result = Buffer.alloc(apdu.length);\n  for (let i = 0; i < apdu.length; i++) {\n    result[i] = apdu[i] ^ key[i % key.length];\n  }\n  return result;\n}\n\n// Convert from normal to web-safe, strip trailing \"=\"s\nconst webSafe64 = (base64: string) =>\n  base64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n\n// Convert from web-safe to normal, add trailing \"=\"s\nconst normal64 = (base64: string) =>\n  base64.replace(/-/g, \"+\").replace(/_/g, \"/\") +\n  \"==\".substring(0, (3 * base64.length) % 4);\n\nfunction attemptExchange(\n  apdu: Buffer,\n  timeoutMillis: number,\n  scrambleKey: Buffer,\n  unwrap: boolean\n): Promise<Buffer> {\n  const keyHandle = wrapApdu(apdu, scrambleKey);\n  const challenge = Buffer.from(\n    \"0000000000000000000000000000000000000000000000000000000000000000\",\n    \"hex\"\n  );\n  const signRequest = {\n    version: \"U2F_V2\",\n    keyHandle: webSafe64(keyHandle.toString(\"base64\")),\n    challenge: webSafe64(challenge.toString(\"base64\")),\n    appId: location.origin,\n  };\n  log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n  return sign(signRequest, timeoutMillis / 1000).then((response) => {\n    const { signatureData } = response;\n    if (typeof signatureData === \"string\") {\n      const data = Buffer.from(normal64(signatureData), \"base64\");\n      let result;\n      if (!unwrap) {\n        result = data;\n      } else {\n        result = data.slice(5);\n      }\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    } else {\n      throw response;\n    }\n  });\n}\n\nlet transportInstances = [];\n\nfunction emitDisconnect() {\n  transportInstances.forEach((t) => t.emit(\"disconnect\"));\n  transportInstances = [];\n}\n\nfunction isTimeoutU2FError(u2fError) {\n  return u2fError.metaData.code === 5;\n}\n\n/**\n * U2F web Transport implementation\n * @example\n * import TransportU2F from \"@ledgerhq/hw-transport-u2f\";\n * ...\n * TransportU2F.create().then(transport => ...)\n */\nexport default class TransportU2F extends Transport<null> {\n  static isSupported = isSupported;\n\n  /*\n   */\n  static list = (): * =>\n    // this transport is not discoverable but we are going to guess if it is here with isSupported()\n    isSupported().then((supported) => (supported ? [null] : []));\n\n  /*\n   */\n  static listen = (observer: *) => {\n    let unsubscribed = false;\n    isSupported().then((supported) => {\n      if (unsubscribed) return;\n      if (supported) {\n        observer.next({ type: \"add\", descriptor: null });\n        observer.complete();\n      } else {\n        observer.error(\n          new TransportError(\n            \"U2F browser support is needed for Ledger. \" +\n              \"Please use Chrome, Opera or Firefox with a U2F extension. \" +\n              \"Also make sure you're on an HTTPS connection\",\n            \"U2FNotSupported\"\n          )\n        );\n      }\n    });\n    return {\n      unsubscribe: () => {\n        unsubscribed = true;\n      },\n    };\n  };\n\n  scrambleKey: Buffer;\n\n  unwrap: boolean = true;\n\n  /**\n   * static function to create a new Transport from a connected Ledger device discoverable via U2F (browser support)\n   */\n  static async open(_: *, _openTimeout?: number = 5000): Promise<TransportU2F> {\n    return new TransportU2F();\n  }\n\n  constructor() {\n    super();\n    transportInstances.push(this);\n  }\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  async exchange(apdu: Buffer): Promise<Buffer> {\n    try {\n      return await attemptExchange(\n        apdu,\n        this.exchangeTimeout,\n        this.scrambleKey,\n        this.unwrap\n      );\n    } catch (e) {\n      const isU2FError = typeof e.metaData === \"object\";\n      if (isU2FError) {\n        if (isTimeoutU2FError(e)) {\n          emitDisconnect();\n        }\n        // the wrapping make error more usable and \"printable\" to the end user.\n        throw wrapU2FTransportError(\n          e,\n          \"Failed to sign with Ledger device: U2F \" + e.metaData.type,\n          \"U2F_\" + e.metaData.code\n        );\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /**\n   */\n  setScrambleKey(scrambleKey: string) {\n    this.scrambleKey = Buffer.from(scrambleKey, \"ascii\");\n  }\n\n  /**\n   */\n  setUnwrap(unwrap: boolean) {\n    this.unwrap = unwrap;\n  }\n\n  close(): Promise<void> {\n    // u2f have no way to clean things up\n    return Promise.resolve();\n  }\n}\n"],"sourceRoot":""}