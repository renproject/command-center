{"version":3,"sources":["../../src/index.js","../../src/TransportWebUSB.js","../../src/hid-framing.js","../../src/webusb.js"],"names":["devices","blue","id","productName","productIdMM","legacyUsbProductId","usbOnly","memorySize","blockSize","getBlockSize","_firwareVersion","nanoS","firmwareVersion","semver","nanoX","bluetoothSpec","serviceUuid","notifyUuid","writeUuid","devicesList","Object","ledgerUSBVendorId","identifyUSBProductId","usbProductId","legacy","d","mm","bluetoothServices","serviceUuidToInfos","deviceModel","i","spec","constructor","device","channel","Math","packetSize","interfaceNumber","e","apdu","a","log","framing","hidFraming","blocks","result","r","buffer","Buffer","acc","this","releaseInterface","gracefullyResetDevice","setScrambleKey","requestLedgerDevice","TransportWebUSB","getLedgerDevices","iface","alternates","transport","onDisconnect","navigator","console","isSupported","list","listen","observer","unsubscribed","getFirstLedgerDevice","type","descriptor","error","window","unsubscribe","asUInt16BE","value","b","initialAcc","data","dataLength","sequence","makeBlocks","nbBlocks","head","chunk","reduceResponse","TransportError","chunkData","getReducedResult","ledgerDevices","vendorId","filters","existingDevices","Promise"],"mappings":"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","file":"static/js/39.0911ba82.chunk.js","sourcesContent":["// @flow\n\nimport semver from \"semver\";\n\n/**\n * The USB product IDs will be defined as MMII, encoding a model (MM) and an interface bitfield (II)\n *\n ** Model\n * Ledger Nano S : 0x10\n * Ledger Blue : 0x00\n * Ledger Nano X : 0x40\n *\n ** Interface support bitfield\n * Generic HID : 0x01\n * Keyboard HID : 0x02\n * U2F : 0x04\n * CCID : 0x08\n * WebUSB : 0x10\n */\n\nexport const IIGenericHID = 0x01;\nexport const IIKeyboardHID = 0x02;\nexport const IIU2F = 0x04;\nexport const IICCID = 0x08;\nexport const IIWebUSB = 0x10;\n\nconst devices = {\n  blue: {\n    id: \"blue\",\n    productName: \"Ledger Blue\",\n    productIdMM: 0x00,\n    legacyUsbProductId: 0x0000,\n    usbOnly: true,\n    memorySize: 480 * 1024,\n    blockSize: 4 * 1024,\n    getBlockSize: (_firwareVersion: string): number => 4 * 1024,\n  },\n  nanoS: {\n    id: \"nanoS\",\n    productName: \"Ledger Nano S\",\n    productIdMM: 0x10,\n    legacyUsbProductId: 0x0001,\n    usbOnly: true,\n    memorySize: 320 * 1024,\n    blockSize: 4 * 1024,\n    getBlockSize: (firmwareVersion: string): number =>\n      semver.lt(semver.coerce(firmwareVersion), \"2.0.0\") ? 4 * 1024 : 2 * 1024,\n  },\n  nanoX: {\n    id: \"nanoX\",\n    productName: \"Ledger Nano X\",\n    productIdMM: 0x40,\n    legacyUsbProductId: 0x0004,\n    usbOnly: false,\n    memorySize: 2 * 1024 * 1024,\n    blockSize: 4 * 1024,\n    getBlockSize: (_firwareVersion: string): number => 4 * 1024,\n    bluetoothSpec: [\n      {\n        // this is the legacy one (prototype version). we will eventually drop it.\n        serviceUuid: \"d973f2e0-b19e-11e2-9e96-0800200c9a66\",\n        notifyUuid: \"d973f2e1-b19e-11e2-9e96-0800200c9a66\",\n        writeUuid: \"d973f2e2-b19e-11e2-9e96-0800200c9a66\",\n      },\n      {\n        serviceUuid: \"13d63400-2c97-0004-0000-4c6564676572\",\n        notifyUuid: \"13d63400-2c97-0004-0001-4c6564676572\",\n        writeUuid: \"13d63400-2c97-0004-0002-4c6564676572\",\n      },\n    ],\n  },\n};\n\nconst productMap = {\n  Blue: \"blue\",\n  \"Nano S\": \"nanoS\",\n  \"Nano X\": \"nanoX\",\n};\n\n// $FlowFixMe\nconst devicesList: DeviceModel[] = Object.values(devices);\n\n/**\n *\n */\nexport const ledgerUSBVendorId = 0x2c97;\n\n/**\n *\n */\nexport const getDeviceModel = (id: DeviceModelId): DeviceModel => {\n  const info = devices[id];\n  if (!info) throw new Error(\"device '\" + id + \"' does not exist\");\n  return info;\n};\n\n/**\n *\n */\nexport const identifyUSBProductId = (usbProductId: number): ?DeviceModel => {\n  const legacy = devicesList.find((d) => d.legacyUsbProductId === usbProductId);\n  if (legacy) return legacy;\n\n  const mm = usbProductId >> 8;\n  const deviceModel = devicesList.find((d) => d.productIdMM === mm);\n  return deviceModel;\n};\n\nexport const identifyProductName = (productName: string): ?DeviceModel => {\n  const productId = productMap[productName];\n  const deviceModel = devicesList.find((d) => d.id === productId);\n\n  return deviceModel;\n};\n\nconst bluetoothServices: string[] = [];\nconst serviceUuidToInfos: {\n  [_: string]: BluetoothInfos,\n} = {};\n\nfor (let id in devices) {\n  const deviceModel = devices[id];\n  const { bluetoothSpec } = deviceModel;\n  if (bluetoothSpec) {\n    for (let i = 0; i < bluetoothSpec.length; i++) {\n      const spec = bluetoothSpec[i];\n      bluetoothServices.push(spec.serviceUuid);\n      serviceUuidToInfos[spec.serviceUuid] = serviceUuidToInfos[\n        spec.serviceUuid.replace(/-/g, \"\")\n      ] = { deviceModel, ...spec };\n    }\n  }\n}\n\n/**\n *\n */\nexport const getBluetoothServiceUuids = () => bluetoothServices;\n\n/**\n *\n */\nexport const getInfosForServiceUuid = (uuid: string): ?BluetoothInfos =>\n  serviceUuidToInfos[uuid.toLowerCase()];\n\n/**\n *\n */\nexport type DeviceModelId = $Keys<typeof devices>;\n\n/**\n *\n */\nexport type DeviceModel = {\n  id: DeviceModelId,\n  productName: string,\n  productIdMM: number,\n  legacyUsbProductId: number,\n  usbOnly: boolean,\n  memorySize: number,\n  // blockSize: number, // THIS FIELD IS DEPRECATED, use getBlockSize\n  getBlockSize: (firmwareVersion: string) => number,\n  bluetoothSpec?: Array<{\n    serviceUuid: string,\n    writeUuid: string,\n    notifyUuid: string,\n  }>,\n};\n\n/**\n *\n */\nexport type BluetoothInfos = {\n  deviceModel: DeviceModel,\n  serviceUuid: string,\n  writeUuid: string,\n  notifyUuid: string,\n};\n","//@flow\nimport Transport from \"@ledgerhq/hw-transport\";\nimport type {\n  Observer,\n  DescriptorEvent,\n  Subscription,\n} from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId } from \"@ledgerhq/devices\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport {\n  TransportOpenUserCancelled,\n  TransportInterfaceNotAvailable,\n  TransportWebUSBGestureRequired,\n  DisconnectedDeviceDuringOperation,\n  DisconnectedDevice,\n} from \"@ledgerhq/errors\";\nimport {\n  getLedgerDevices,\n  getFirstLedgerDevice,\n  requestLedgerDevice,\n  isSupported,\n} from \"./webusb\";\n\nconst configurationValue = 1;\nconst endpointNumber = 3;\n\n/**\n * WebUSB Transport implementation\n * @example\n * import TransportWebUSB from \"@ledgerhq/hw-transport-webusb\";\n * ...\n * TransportWebUSB.create().then(transport => ...)\n */\nexport default class TransportWebUSB extends Transport<USBDevice> {\n  device: USBDevice;\n  deviceModel: ?DeviceModel;\n  channel = Math.floor(Math.random() * 0xffff);\n  packetSize = 64;\n  interfaceNumber: number;\n\n  constructor(device: USBDevice, interfaceNumber: number) {\n    super();\n    this.device = device;\n    this.interfaceNumber = interfaceNumber;\n    this.deviceModel = identifyUSBProductId(device.productId);\n  }\n\n  /**\n   * Check if WebUSB transport is supported.\n   */\n  static isSupported = isSupported;\n\n  /**\n   * List the WebUSB devices that was previously authorized by the user.\n   */\n  static list = getLedgerDevices;\n\n  /**\n   * Actively listen to WebUSB devices and emit ONE device\n   * that was either accepted before, if not it will trigger the native permission UI.\n   *\n   * Important: it must be called in the context of a UI click!\n   */\n  static listen = (\n    observer: Observer<DescriptorEvent<USBDevice>>\n  ): Subscription => {\n    let unsubscribed = false;\n    getFirstLedgerDevice().then(\n      (device) => {\n        if (!unsubscribed) {\n          const deviceModel = identifyUSBProductId(device.productId);\n          observer.next({ type: \"add\", descriptor: device, deviceModel });\n          observer.complete();\n        }\n      },\n      (error) => {\n        if (\n          window.DOMException &&\n          error instanceof window.DOMException &&\n          error.code === 18\n        ) {\n          observer.error(new TransportWebUSBGestureRequired(error.message));\n        } else {\n          observer.error(new TransportOpenUserCancelled(error.message));\n        }\n      }\n    );\n    function unsubscribe() {\n      unsubscribed = true;\n    }\n    return { unsubscribe };\n  };\n\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n  static async request() {\n    const device = await requestLedgerDevice();\n    return TransportWebUSB.open(device);\n  }\n\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n  static async openConnected() {\n    const devices = await getLedgerDevices();\n    if (devices.length === 0) return null;\n    return TransportWebUSB.open(devices[0]);\n  }\n\n  /**\n   * Create a Ledger transport with a USBDevice\n   */\n  static async open(device: USBDevice) {\n    await device.open();\n    if (device.configuration === null) {\n      await device.selectConfiguration(configurationValue);\n    }\n    const iface = device.configurations[0].interfaces.find(({ alternates }) =>\n      alternates.some((a) => a.interfaceClass === 255)\n    );\n    if (!iface) {\n      throw new TransportInterfaceNotAvailable(\n        \"No WebUSB interface found for your Ledger device. Please upgrade firmware or contact techsupport.\"\n      );\n    }\n    const interfaceNumber = iface.interfaceNumber;\n    try {\n      await device.claimInterface(interfaceNumber);\n    } catch (e) {\n      await device.close();\n      throw new TransportInterfaceNotAvailable(e.message);\n    }\n    const transport = new TransportWebUSB(device, interfaceNumber);\n    const onDisconnect = (e) => {\n      if (device === e.device) {\n        // $FlowFixMe\n        navigator.usb.removeEventListener(\"disconnect\", onDisconnect);\n        transport._emitDisconnect(new DisconnectedDevice());\n      }\n    };\n    // $FlowFixMe\n    navigator.usb.addEventListener(\"disconnect\", onDisconnect);\n    return transport;\n  }\n\n  _disconnectEmitted = false;\n  _emitDisconnect = (e: Error) => {\n    if (this._disconnectEmitted) return;\n    this._disconnectEmitted = true;\n    this.emit(\"disconnect\", e);\n  };\n\n  /**\n   * Release the transport device\n   */\n  async close(): Promise<void> {\n    await this.exchangeBusyPromise;\n    await this.device.releaseInterface(this.interfaceNumber);\n    await gracefullyResetDevice(this.device);\n    await this.device.close();\n  }\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  exchange = (apdu: Buffer): Promise<Buffer> =>\n    this.exchangeAtomicImpl(async () => {\n      const { channel, packetSize } = this;\n      log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n\n      const framing = hidFraming(channel, packetSize);\n\n      // Write...\n      const blocks = framing.makeBlocks(apdu);\n      for (let i = 0; i < blocks.length; i++) {\n        await this.device.transferOut(endpointNumber, blocks[i]);\n      }\n\n      // Read...\n      let result;\n      let acc;\n      while (!(result = framing.getReducedResult(acc))) {\n        const r = await this.device.transferIn(endpointNumber, packetSize);\n        const buffer = Buffer.from(r.data.buffer);\n        acc = framing.reduceResponse(acc, buffer);\n      }\n\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    }).catch((e) => {\n      if (e && e.message && e.message.includes(\"disconnected\")) {\n        this._emitDisconnect(e);\n        throw new DisconnectedDeviceDuringOperation(e.message);\n      }\n      throw e;\n    });\n\n  setScrambleKey() {}\n}\n\nasync function gracefullyResetDevice(device: USBDevice) {\n  try {\n    await device.reset();\n  } catch (err) {\n    console.warn(err);\n  }\n}\n","// @flow\n\nimport { TransportError } from \"@ledgerhq/errors\";\n\nexport type ResponseAcc = ?{\n  data: Buffer,\n  dataLength: number,\n  sequence: number,\n};\n\nconst Tag = 0x05;\n\nfunction asUInt16BE(value) {\n  const b = Buffer.alloc(2);\n  b.writeUInt16BE(value, 0);\n  return b;\n}\n\nconst initialAcc = {\n  data: Buffer.alloc(0),\n  dataLength: 0,\n  sequence: 0,\n};\n\n/**\n *\n */\nconst createHIDframing = (channel: number, packetSize: number) => {\n  return {\n    makeBlocks(apdu: Buffer): Buffer[] {\n      let data = Buffer.concat([asUInt16BE(apdu.length), apdu]);\n      const blockSize = packetSize - 5;\n      const nbBlocks = Math.ceil(data.length / blockSize);\n      data = Buffer.concat([\n        data, // fill data with padding\n        Buffer.alloc(nbBlocks * blockSize - data.length + 1).fill(0),\n      ]);\n\n      const blocks = [];\n      for (let i = 0; i < nbBlocks; i++) {\n        const head = Buffer.alloc(5);\n        head.writeUInt16BE(channel, 0);\n        head.writeUInt8(Tag, 2);\n        head.writeUInt16BE(i, 3);\n        const chunk = data.slice(i * blockSize, (i + 1) * blockSize);\n        blocks.push(Buffer.concat([head, chunk]));\n      }\n      return blocks;\n    },\n\n    reduceResponse(acc: ResponseAcc, chunk: Buffer): ResponseAcc {\n      let { data, dataLength, sequence } = acc || initialAcc;\n\n      if (chunk.readUInt16BE(0) !== channel) {\n        throw new TransportError(\"Invalid channel\", \"InvalidChannel\");\n      }\n      if (chunk.readUInt8(2) !== Tag) {\n        throw new TransportError(\"Invalid tag\", \"InvalidTag\");\n      }\n      if (chunk.readUInt16BE(3) !== sequence) {\n        throw new TransportError(\"Invalid sequence\", \"InvalidSequence\");\n      }\n\n      if (!acc) {\n        dataLength = chunk.readUInt16BE(5);\n      }\n      sequence++;\n      const chunkData = chunk.slice(acc ? 5 : 7);\n      data = Buffer.concat([data, chunkData]);\n      if (data.length > dataLength) {\n        data = data.slice(0, dataLength);\n      }\n\n      return {\n        data,\n        dataLength,\n        sequence,\n      };\n    },\n\n    getReducedResult(acc: ResponseAcc): ?Buffer {\n      if (acc && acc.dataLength === acc.data.length) {\n        return acc.data;\n      }\n    },\n  };\n};\n\nexport default createHIDframing;\n","// @flow\nimport { ledgerUSBVendorId } from \"@ledgerhq/devices\";\n\nconst ledgerDevices = [{ vendorId: ledgerUSBVendorId }];\n\nexport async function requestLedgerDevice(): Promise<USBDevice> {\n  // $FlowFixMe\n  const device = await navigator.usb.requestDevice({ filters: ledgerDevices });\n  return device;\n}\n\nexport async function getLedgerDevices(): Promise<USBDevice[]> {\n  // $FlowFixMe\n  const devices = await navigator.usb.getDevices();\n  return devices.filter((d) => d.vendorId === ledgerUSBVendorId);\n}\n\nexport async function getFirstLedgerDevice(): Promise<USBDevice> {\n  const existingDevices = await getLedgerDevices();\n  if (existingDevices.length > 0) return existingDevices[0];\n  return requestLedgerDevice();\n}\n\nexport const isSupported = (): Promise<boolean> =>\n  Promise.resolve(\n    !!navigator &&\n      // $FlowFixMe\n      !!navigator.usb &&\n      typeof navigator.usb.getDevices === \"function\"\n  );\n"],"sourceRoot":""}